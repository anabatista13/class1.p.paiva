#include <stdio.h>
#include <stdlib.h> // Para malloc, free e qsort [cite: 7, 8]
#include <math.h>   // Para sqrt e pow

// --- Protótipos das Funções ---
// Funções com nomes claros para fins acadêmicos
int comparar_double(const void *a, const void *b);
double calcular_minimo(double *vetor, int N);
double calcular_maximo(double *vetor, int N);
double calcular_media(double *vetor, int N);
double calcular_mediana(double *vetor_ordenado, int N);
double calcular_desvio_padrao(double *vetor, int N, double media);

// -----------------------------------------------------------------

int main() {
    int N;
    double *serie = NULL; // Ponteiro para a série alocada dinamicamente [cite: 1]
    
    printf("Quantos números na sua série (N): ");
    if (scanf("%d", &N) != 1 || N <= 0) {
        fprintf(stderr, "Erro: N deve ser um inteiro positivo.\n");
        return 1;
    }

    // 1. Alocação Dinâmica de Memória (Memória alocada em tempo de execução) [cite: 5, 6, 11]
    // Aloca N espaços para doubles (Usando sizeof() como demonstrado no material) [cite: 18]
    serie = (double *)malloc(N * sizeof(double));
    if (serie == NULL) { // Verifica a alocação [cite: 11]
        fprintf(stderr, "ERRO: Falha na alocação dinâmica de memória.\n");
        return 1;
    }

    // 2. Leitura dos Dados
    printf("Entre com números:\n");
    for (int i = 0; i < N; i++) {
        printf("> ");
        if (scanf("%lf", &serie[i]) != 1) {
            fprintf(stderr, "Erro na leitura de dados.\n");
            free(serie); // Libera a memória em caso de erro [cite: 27]
            return 1;
        }
    }

    // 3. Cálculos Estatísticos
    double min = calcular_minimo(serie, N);
    double max = calcular_maximo(serie, N);
    double media = calcular_media(serie, N);

    // Ordena o vetor (necessário para a mediana)
    qsort(serie, N, sizeof(double), comparar_double);
    double mediana = calcular_mediana(serie, N);

    double desvio_padrao = calcular_desvio_padrao(serie, N, media);

    // 4. Apresentação dos Resultados
    printf("\nValor mínimo: %.1lf\n", min);
    printf("Valor Máximo: %.1lf\n", max);
    printf("Média: %.2lf\n", media);
    printf("Mediana: %.2lf\n", mediana);
    printf("Desvio padrão: %.11lf\n", desvio_padrao);

    // 5. Liberação da Memória [cite: 27]
    free(serie); 
    
    return 0;
}

// -----------------------------------------------------------------
// ----------------- IMPLEMENTAÇÃO DAS FUNÇÕES ---------------------
// -----------------------------------------------------------------

int comparar_double(const void *a, const void *b) {
    if (*(const double *)a < *(const double *)b) return -1;
    if (*(const double *)a > *(const double *)b) return 1;
    return 0;
}

double calcular_minimo(double *v, int N) {
    double min = v[0];
    for (int i = 1; i < N; i++) if (v[i] < min) min = v[i];
    return min;
}

double calcular_maximo(double *v, int N) {
    double max = v[0];
    for (int i = 1; i < N; i++) if (v[i] > max) max = v[i];
    return max;
}

double calcular_media(double *v, int N) {
    double soma = 0.0;
    for (int i = 0; i < N; i++) soma += v[i];
    return soma / N;
}

double calcular_mediana(double *v, int N) {
    // Retorna a média dos dois centrais (N par) ou o elemento central (N ímpar)
    return (N % 2 != 0) ? v[N / 2] : (v[N / 2 - 1] + v[N / 2]) / 2.0;
}

double calcular_desvio_padrao(double *v, int N, double media) {
    double soma_quadrados = 0.0;
    // Calcula a soma dos quadrados das diferenças (xi - média)²
    for (int i = 0; i < N; i++) soma_quadrados += pow(v[i] - media, 2);
    // Retorna a raiz quadrada da variância (soma_quadrados / N)
    return sqrt(soma_quadrados / N);
}
